[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Blog",
    "section": "",
    "text": "Atividade 3\n\n\n\nlinear\n\ncódigo\n\n\n\n\n\n\n\n\n\nNov 20, 2025\n\n\nlineee\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 2\n\n\n\nônibus\n\ncódigo\n\n\n\n\n\n\n\n\n\nNov 19, 2025\n\n\nVrum vrum\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 1\n\n\n\ndólar\n\ncódigo\n\n\n\n\n\n\n\n\n\nNov 18, 2025\n\n\nMoney money\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Atividade 2",
    "section": "",
    "text": "Monitoramento de Frota de Ônibus\n\n\n\n\n\n\nfasfasdasd asdasdasda"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Giovanna Nunes Alexandre",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Atividade 1",
    "section": "",
    "text": "Cotação do Dólar por Período\n\n\n\n\n\n\n \n\nObjetivo da atividade\n\nNesta atividade, a ideia era pegar um mês e ano no formato \"MMYYYY\" e usar isso para buscar na API do Banco Central a cotação diária do dólar daquele período. No meu caso, o mês é 06/2011.\nPrimeiro, o código transforma esse “062011” em uma data que o Python entende. Depois descubro qual é o último dia do mês e monto o intervalo certinho para mandar para a API.\nA API não traz todos os dias, só os dias em que realmente teve cotação. Então, depois que recebo os dados, eu crio uma lista com todos os dias do mês, junto com as cotações da API, e completo os dias que faltam usando o valor do dia anterior (igual explicado na orientação da atividade).\nPor fim, com tudo organizado num DataFrame, eu uso o Plotly para fazer o gráfico de linha mostrando como o dólar mudou ao longo do mês. É basicamente isso: pegar a data, consultar a API, arrumar os dados e gerar o gráfico.\nA partir dessas orientações, montei o seguinte código:\nimport requests\nimport pandas as pd\nimport plotly.express as px\nimport calendar\nfrom datetime import datetime\n\ndef gerar_grafico_cotacao(mes_ano):\n    # 1. Transformar \"MMYYYY\" em uma data real\n    inicio = datetime.strptime(mes_ano, \"%m%Y\")\n    \n    # Último dia do mês\n    ultimo_dia = calendar.monthrange(inicio.year, inicio.month)[1]\n    fim = inicio.replace(day=ultimo_dia)\n\n    # A API NÃO aceita MMYYYY como data, então tem que criar datas completas\n    data_inicial_api = inicio.strftime(\"%m-%d-%Y\")   # formato aceito pela API\n    data_final_api   = fim.strftime(\"%m-%d-%Y\")\n\n    # 2. Montar a URL da API PTAX\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@ini,dataFinalCotacao=@fim)?\"\n        f\"@ini='{data_inicial_api}'&@fim='{data_final_api}'&\"\n        \"$format=json&$select=cotacaoCompra,dataHoraCotacao\"\n    )\n\n    # 3. Fazer requisição\n    resposta = requests.get(url)\n    dados = resposta.json().get(\"value\", [])\n\n    if not dados:\n        print(\"Nenhuma cotação encontrada para esse mês.\")\n        return\n\n    # 4. Organizar os dados\n    df = pd.DataFrame(dados)\n    df[\"dataHoraCotacao\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df.sort_values(\"dataHoraCotacao\")\n\n    # 5. Criar o gráfico\n    fig = px.line(\n        df,\n        x=\"dataHoraCotacao\",\n        y=\"cotacaoCompra\",\n        title=f\"Cotação do Dólar – {inicio.month:02d}/{inicio.year}\",\n        labels={\"dataHoraCotacao\": \"Data\", \"cotacaoCompra\": \"Cotação (R$)\"}\n    )\n\n    fig.show()\n\n# Rodando com o meu mês (junho de 2011)\ngerar_grafico_cotacao(\"062011\")\n\n\nFinalizando a atividade\n\nCom tudo feito, deu para entender bem como funciona o processo de buscar informações da API do Banco Central e transformar esses dados em algo visual. A parte mais importante foi montar as datas certinhas a partir do formato “MMYYYY”, já que a API precisa de datas completas para funcionar.\nDepois de pegar as cotações, organizar em tabela e gerar o gráfico, fica bem mais fácil enxergar como o dólar se comportou durante o mês analisado. No meu caso, junho de 2011. Essa atividade ajudou bastante a praticar requisições, manipulação de datas e o uso do Plotly para criar gráficos. Tudo isso vai ser útil nas próximas partes do trabalho"
  },
  {
    "objectID": "sobre.html",
    "href": "sobre.html",
    "title": "Giovanna Nunes Alexandre",
    "section": "",
    "text": "Engenharia da computação\n\n\nRA: 224928"
  },
  {
    "objectID": "posts/regressao-linear/index.html",
    "href": "posts/regressao-linear/index.html",
    "title": "Atividade 3",
    "section": "",
    "text": "Regressão Linear\n\n\n\n\n\n\n \n\nObjetivo da atividade\n\nA proposta desta atividade foi trabalhar com o conceito de regressão linear utilizando um conjunto de dados fornecidos. A ideia foi analisar a relação entre duas variáveis, neste caso, valores de x e y simulando anos de estudo e salário e, a partir disso, ajustar uma reta que melhor descreve essa relação. Para isso, foi solicitado que o cálculo fosse feito por meio da fórmula matricial da regressão linear, sem utilizar funções prontas. Depois, os resultados deveriam ser apresentados em um gráfico contendo tanto os pontos originais quanto a linha estimada.\nA partir dessas orientações, segue o código:\nimport numpy as np\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_point, geom_abline\nfrom PIL import Image\nfrom pathlib import Path # NOVO: Importa para lidar com caminhos\n\n# --- CORREÇÃO DO CARREGAMENTO DE DADOS (Mínimas Alterações) ---\n\n# 1. Carregar os dados\n# Descobre o diretório do script e constrói o caminho absoluto para os arquivos.\n# Isso resolve o problema de o VS Code não saber qual é o diretório de trabalho (CWD).\ntry:\n    # Obtém o diretório do script\n    diretorio_script = Path(__file__).resolve().parent\n    \n    # Constrói o caminho completo para os arquivos\n    caminho_x = diretorio_script / \"x.txt\"\n    caminho_y = diretorio_script / \"y.txt\"\n\n    # Carrega os dados usando o caminho absoluto\n    X = np.loadtxt(caminho_x)\n    y = np.loadtxt(caminho_y)\n    \nexcept NameError:\n    # Caso o script seja executado em um ambiente sem __file__ (raro em VS Code)\n    # Usa a abordagem de caminho relativo como fallback, que é a original.\n    X = np.loadtxt(\"x.txt\")\n    y = np.loadtxt(\"y.txt\")\n\n# --- FIM DA CORREÇÃO ---\n\n# Garantir que X seja uma matriz coluna\nX = X.reshape(-1, 1)\n\n# 2. Adicionar coluna de 1s para o intercepto\nX_b = np.hstack([np.ones((X.shape[0], 1)), X])\n\n# 3. Fórmula matricial da regressão linear\nbeta = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n\na = beta[0] # intercepto\nb = beta[1] # coeficiente angular\n\nprint(f\"Intercepto (a): {a}\")\nprint(f\"Slope (b): {b}\")\n\n# 4. Gerar gráfico\ndf = pd.DataFrame({\"x\": X.flatten(), \"y\": y})\n\nplot = (\n  ggplot(df, aes(\"x\", \"y\"))\n  + geom_point()\n  + geom_abline(intercept=a, slope=b)\n)\n\n# 5. Salvar gráfico\nplot.save(\"grafico.png\")\n\n# 6. Abre o gráfico automaticamente\nimg = Image.open(\"grafico.png\")\nimg.show()\n\n\nFinalizando a atividade\n\nApós organizar os dados e montar a matriz do modelo, apliquei diretamente a fórmula matricial da regressão linear para obter os coeficientes da reta, representados pelo intercepto e pela inclinação. Com esses valores calculados, foi criado um gráfico mostrando os pontos fornecidos e a linha ajustada. O código utilizado faz exatamente o que foi pedido: calcula os parâmetros da regressão a partir da álgebra matricial e gera um gráfico final que permite visualizar a tendência da relação entre as variáveis."
  },
  {
    "objectID": "posts/frota-onibus/index.html",
    "href": "posts/frota-onibus/index.html",
    "title": "Atividade 2",
    "section": "",
    "text": "Monitoramento de Frota de Ônibus\n\n\n\n\n\n\n \n\nObjetivo da atividade\n\nNesta atividade, a proposta foi acessar a API Olho Vivo da SPTrans usando o token disponibilizado após a criação de um login, e consultar uma linha de ônibus real. A partir disso, gerar um mapa com as paradas e, quando possível, a posição dos veículos em tempo real. Pelo que entendi, o foco da tarefa era saber se conectar a uma API, interpretar os dados que ela devolve e transformar essas informações em algo visual e útil, usando Python.\nCom essa ideia em mente, comecei organizando o código por etapas: primeiro verifiquei se a autenticação estava funcionando, depois fui atrás da linha escolhida, das paradas e, por fim, construí o mapa interativo reunindo tudo isso, seguindo também o que foi mostrado nos slides. Dessa forma, deixei explicado cada parte do processo dentro do próprio código, conforme foi pedido.\nA partir dessas orientações, segue o código:\nimport requests\nimport folium\nfrom folium import Map, CircleMarker, Popup\nimport statistics\n\n# 1. Meu token\nSPTRANS_TOKEN = \"deca79917d3e50d27a89803c19b203e9ec1f634558ee08f5d0c17c006c39c5c5\"\n\n# 2. Linha que escolhi - Terminal Pirituba a Vila Mirante (Linha Noturna)\nCODIGO_LINHA = \"N140-11\"\n\n# 3. Funções auxiliares\ndef autenticar(session, token):\n    # Autentica no Olho Vivo com o token e retorna True se ok\n    url_login = f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={token}\"\n    resp = session.post(url_login)\n    print(\"Resposta do login:\", resp.text.strip(), \"| status:\", resp.status_code)\n    return resp.status_code == 200 and resp.text.strip().lower() == \"true\"\n\ndef buscar_linhas_por_termo(session, termo):\n    # Procura linhas que contenham o termo (retorna lista de dicts)\n    url = \"http://api.olhovivo.sptrans.com.br/v2.1/Linha/Buscar\"\n\n    # Conforme a documentação oficial da SPtrans, /linha/buscar deve ser acessada via GET\n    r = session.get(url, params={\"termosBusca\": termo})\n\n    r.raise_for_status()\n    return r.json()\n\ndef resolver_cl(session, termo):\n\n    # Recebe um termo/letreiro (ex: \"N140-11\") e tenta retornar o código interno 'cl'\n    Retorna None se não encontrar.\n\n    linhas = buscar_linhas_por_termo(session, termo)\n    if not linhas:\n        return None\n\n    # tenta correspondência exata no letreiro\n    for l in linhas:\n        if str(l.get(\"lt\", \"\")).upper() == str(termo).upper():\n            return l.get(\"cl\")\n\n    # senão devolve o primeiro disponível\n    return linhas[0].get(\"cl\")\n\ndef buscar_paradas(session, codigo_linha):\n    # Retorna lista de paradas (cada item com px, py, np, cp etc.)\n    url = \"http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha\"\n    r = session.get(url, params={\"codigoLinha\": codigo_linha})\n    r.raise_for_status()\n    return r.json()\n\ndef buscar_posicoes(session, codigo_linha):\n    # Retorna posições atuais da linha\n    url = \"http://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha\"\n    r = session.get(url, params={\"codigoLinha\": codigo_linha})\n    r.raise_for_status()\n    return r.json()\n\n# 4. Rotina principal\ndef construir_mapa_linha(token, codigo_linha_input, salvar_html=\"mapa_frota.html\"):\n    s = requests.Session()\n\n    print(\"Autenticando no Olho Vivo...\")\n    ok = autenticar(s, token)\n    if not ok:\n        print(\"Erro na autenticação. Verifique o token.\")\n        return\n\n    # Se for letreiro, converte para CL\n    codigo_cl = codigo_linha_input\n    if isinstance(codigo_linha_input, str) and not codigo_linha_input.isdigit():\n        print(f\"'{codigo_linha_input}' parece ser um letreiro — vou buscar o código interno (cl)...\")\n        codigo_cl = resolver_cl(s, codigo_linha_input)\n        if codigo_cl is None:\n            print(\"Não encontrei um código interno para esse letreiro.\")\n            return\n        print(f\"Código interno (cl) encontrado: {codigo_cl}\")\n\n    print(f\"Buscando paradas da linha {codigo_cl}...\")\n    paradas = buscar_paradas(s, codigo_cl)\n    if not paradas:\n        print(\"Nenhuma parada encontrada para essa linha.\")\n        return\n\n    lats = [p[\"py\"] for p in paradas if p.get(\"py\") is not None]\n    lons = [p[\"px\"] for p in paradas if p.get(\"px\") is not None]\n    if not lats or not lons:\n        print(\"Paradas não possuem coordenadas válidas.\")\n        return\n\n    center = [statistics.mean(lats), statistics.mean(lons)]\n    m = Map(location=center, zoom_start=14)\n\n    # Paradas — azul\n    for p in paradas:\n        lat = p.get(\"py\")\n        lon = p.get(\"px\")\n        nome = p.get(\"np\") or \"Parada\"\n        endereco = p.get(\"ed\") or \"\"\n        popup_text = f\"{nome} &lt;br&gt;{endereco} &lt;br&gt;CP: {p.get('cp')}\"\n        CircleMarker(\n            location=[lat, lon],\n            radius=5,\n            color=\"blue\",\n            fill=True,\n            fill_opacity=0.7,\n            popup=Popup(popup_text, max_width=300)\n        ).add_to(m)\n\n    print(\"Buscando posições em tempo real...\")\n    pos = buscar_posicoes(s, codigo_cl)\n    vehicles = pos.get(\"vs\", []) if isinstance(pos, dict) else []\n\n    # Veículos — vermelho\n    for v in vehicles:\n        lat = v.get(\"py\")\n        lon = v.get(\"px\")\n        placa = v.get(\"p\")\n        ativo = v.get(\"a\")\n        ta = v.get(\"ta\")\n        popup = f\"Veículo: {placa}&lt;br&gt;Ativo: {ativo}&lt;br&gt;Horário: {ta}\"\n        CircleMarker(\n            location=[lat, lon],\n            radius=6,\n            color=\"red\",\n            fill=True,\n            fill_opacity=0.9,\n            popup=Popup(popup, max_width=250)\n        ).add_to(m)\n\n    # Legenda\n    folium.map.Marker(\n        location=[center[0] + 0.01, center[1] - 0.02],\n        icon=folium.DivIcon(html=\"&lt;div style='font-size:12px'&gt;&lt;span style='color:blue'&gt;&#9679;&lt;/span&gt; Paradas &nbsp;&nbsp; &lt;span style='color:red'&gt;&#9679;&lt;/span&gt; Ônibus&lt;/div&gt;\")\n    ).add_to(m)\n\n    m.save(salvar_html)\n    print(f\"Mapa salvo em: {salvar_html}\")\n\n# 5. Execução\nif __name__ == \"__main__\":\n    construir_mapa_linha(SPTRANS_TOKEN, CODIGO_LINHA, salvar_html=\"mapa_linha_N140-11.html\")\n\n\nFinalizando a atividade\n\nO programa realiza a autenticação por meio do token fornecido, faz a busca da linha informada pelo usuário e obtém automaticamente o código interno (CL) necessário para consultar os demais dados da API. No caso deste trabalho, a linha utilizada foi N140-11 (Terminal Pirituba a Vila Mirante - Linha Noturna), e o sistema identifica corretamente seu código interno antes de seguir para as próximas etapas.\nApós a autenticação bem-sucedida, o código consulta todas as paradas oficiais da linha, recuperando informações como nome, endereço, coordenadas e código da parada. Em seguida, obtém também os veículos em operação naquele momento, incluindo posição geográfica, placa, horário da última atualização e status de atividade.\nPor fim, o programa gera automaticamente um mapa interativo, utilizando a biblioteca Folium. No mapa, cada parada da linha é representada por um marcador azul, enquanto os ônibus aparecem como marcadores vermelhos, ambos com pop-ups informativos. Também é adicionada uma legenda para facilitar a visualização e identificar os elementos exibidos.\nO arquivo final, salvo em HTML, pode ser aberto em qualquer navegador e permite ao usuário navegar pelo mapa, visualizar as paradas e acompanhar as posições atuais dos veículos. Dessa forma, o código atende plenamente ao objetivo da atividade, e gera o que foi solicitado."
  },
  {
    "objectID": "posts/cotacao-dolar/index.html",
    "href": "posts/cotacao-dolar/index.html",
    "title": "Atividade 1",
    "section": "",
    "text": "Cotação do Dólar por Período\n\n\n\n\n\n\n \n\nObjetivo da atividade\n\nNesta atividade, a ideia era pegar um mês e ano no formato \"MMYYYY\" e usar isso para buscar na API do Banco Central a cotação diária do dólar daquele período. No meu caso, o mês é 06/2011.\nPrimeiro, o código transforma esse “062011” em uma data que o Python entende. Depois descubro qual é o último dia do mês e monto o intervalo certinho para mandar para a API.\nA API não traz todos os dias, só os dias em que realmente teve cotação. Então, depois que recebo os dados, eu crio uma lista com todos os dias do mês, junto com as cotações da API, e completo os dias que faltam usando o valor do dia anterior (igual explicado na orientação da atividade).\nPor fim, com tudo organizado num DataFrame, eu uso o Plotly para fazer o gráfico de linha mostrando como o dólar mudou ao longo do mês. É basicamente isso: pegar a data, consultar a API, arrumar os dados e gerar o gráfico.\nA partir dessas orientações, segue o código:\nimport requests\nimport pandas as pd\nimport plotly.express as px\nimport calendar\nfrom datetime import datetime\n\ndef gerar_grafico_cotacao(mes_ano):\n    # 1. Transforma \"MMYYYY\" em uma data real\n    inicio = datetime.strptime(mes_ano, \"%m%Y\")\n    \n    # Último dia do mês\n    ultimo_dia = calendar.monthrange(inicio.year, inicio.month)[1]\n    fim = inicio.replace(day=ultimo_dia)\n\n    # A API NÃO aceita MMYYYY como data, então tem que criar datas completas\n    data_inicial_api = inicio.strftime(\"%m-%d-%Y\")   \n    # formato aceito pela API\n    data_final_api   = fim.strftime(\"%m-%d-%Y\")\n\n    # 2. Montar a URL da API PTAX\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@ini,dataFinalCotacao=@fim)?\"\n        f\"@ini='{data_inicial_api}'&@fim='{data_final_api}'&\"\n        \"$format=json&$select=cotacaoCompra,dataHoraCotacao\"\n    )\n\n    # 3. Fazer requisição\n    resposta = requests.get(url)\n    dados = resposta.json().get(\"value\", [])\n\n    if not dados:\n        print(\"Nenhuma cotação encontrada para esse mês.\")\n        return\n\n    # 4. Organizar os dados\n    df = pd.DataFrame(dados)\n    df[\"dataHoraCotacao\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df.sort_values(\"dataHoraCotacao\")\n\n    # 5. Criar o gráfico\n    fig = px.line(\n        df,\n        x=\"dataHoraCotacao\",\n        y=\"cotacaoCompra\",\n        title=f\"Cotação do Dólar – {inicio.month:02d}/{inicio.year}\",\n        labels={\"dataHoraCotacao\": \"Data\", \"cotacaoCompra\": \"Cotação (R$)\"}\n    )\n\n    fig.show()\n\n# Rodando com o meu mês (junho de 2011)\ngerar_grafico_cotacao(\"062011\")\n\n\nFinalizando a atividade\n\nCom tudo feito, deu para entender bem como funciona o processo de buscar informações da API do Banco Central e transformar esses dados em algo visual. A parte mais importante foi montar as datas certinhas a partir do formato “MMYYYY”, já que a API precisa de datas completas para funcionar.\nDepois de pegar as cotações, organizar em tabela e gerar o gráfico, fica bem mais fácil enxergar como o dólar se comportou durante o mês analisado. No meu caso, junho de 2011. Essa atividade ajudou bastante a praticar requisições, manipulação de datas e o uso do Plotly para criar gráficos. Tudo isso vai ser útil nas próximas partes do trabalho"
  }
]